#!/usr/bin/env python3
"""
Precision Agriculture Analytics Dashboard
Reads synthetic data generated by Kingfisher and creates comprehensive visualizations
using the Streamlit framework.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import warnings
from datetime import datetime, timedelta
import random
import streamlit as st

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

# Set style for matplotlib
plt.style.use('default')
sns.set_palette("husl")


class AgricultureAnalyticsDashboard:
    def __init__(self):
        self.farms_df = None
        self.fields_df = None
        self.crops_df = None
        self.sensor_readings_df = None
        self.field_operations_df = None
        self.harvest_records_df = None

    def load_data(self):
        """Load CSV files generated by Kingfisher synthetic data generator"""
        try:
            # Load main tables
            self.farms_df = pd.read_csv('farms.csv')
            self.fields_df = pd.read_csv('fields.csv')
            self.crops_df = pd.read_csv('crops.csv')
            self.sensor_readings_df = pd.read_csv('sensor_readings.csv')
            self.field_operations_df = pd.read_csv('field_operations.csv')
            self.harvest_records_df = pd.read_csv('harvest_records.csv')

            # Convert date columns
            self.sensor_readings_df['reading_timestamp'] = pd.to_datetime(self.sensor_readings_df['reading_timestamp'])
            self.field_operations_df['operation_date'] = pd.to_datetime(self.field_operations_df['operation_date'])
            self.harvest_records_df['harvest_date'] = pd.to_datetime(self.harvest_records_df['harvest_date'])

            st.success("‚úÖ All CSV files loaded successfully!")
            st.info(f"""
            üìä **Data Summary:**
            - **Farms:** {len(self.farms_df):,} records
            - **Fields:** {len(self.fields_df):,} records
            - **Crops:** {len(self.crops_df):,} records
            - **Sensor Readings:** {len(self.sensor_readings_df):,} records
            - **Field Operations:** {len(self.field_operations_df):,} records
            - **Harvest Records:** {len(self.harvest_records_df):,} records
            """)

        except FileNotFoundError as e:
            st.warning(f"‚ùå Error loading data: {e}")
            st.info("üîÑ Generating sample synthetic data for demonstration...")
            self.generate_sample_data()

    def generate_sample_data(self):
        """Generate sample synthetic data for demonstration when CSV files aren't available"""
        np.random.seed(42)
        random.seed(42)

        # Generate sample farms data
        self.farms_df = pd.DataFrame({
            'farm_id': [f'FARM_{i:03d}' for i in range(1, 26)],
            'farm_name': [f'Farm {i}' for i in range(1, 26)],
            'location_state': np.random.choice(['Iowa', 'Illinois', 'Nebraska', 'Kansas', 'Minnesota'], 25),
            'location_county': [f'County {i}' for i in range(1, 26)],
            'total_acres': np.random.uniform(500, 2500, 25),
            'farm_type': np.random.choice(['Conventional', 'Organic', 'Mixed'], 25, p=[0.6, 0.25, 0.15]),
            'certification_organic': np.random.choice([True, False], 25, p=[0.3, 0.7])
        })

        # Generate sample fields data
        fields_data = []
        for farm_id in self.farms_df['farm_id']:
            num_fields = np.random.randint(3, 8)
            farm_acres = self.farms_df[self.farms_df['farm_id'] == farm_id]['total_acres'].values[0]

            for field_num in range(1, num_fields + 1):
                fields_data.append({
                    'field_id': f'{farm_id}_FIELD_{field_num:02d}',
                    'farm_id': farm_id,
                    'field_name': f'Field {field_num}',
                    'field_acres': np.random.uniform(50, farm_acres / num_fields * 1.5),
                    'soil_type': np.random.choice(['Clay', 'Loam', 'Sand', 'Silt']),
                    'soil_ph': np.random.uniform(5.5, 7.5),
                    'irrigation_type': np.random.choice(['Sprinkler', 'Drip', 'Flood', 'Rain-fed'])
                })

        self.fields_df = pd.DataFrame(fields_data)

        # Load crops lookup data
        crops_data = [
            {'crop_id': 'CROP_CORN_001', 'crop_name': 'Corn', 'crop_category': 'Grain', 'expected_yield_per_acre': 175,
             'market_price_per_unit': 4.25},
            {'crop_id': 'CROP_SOYBEAN_001', 'crop_name': 'Soybeans', 'crop_category': 'Legume',
             'expected_yield_per_acre': 55, 'market_price_per_unit': 11.50},
            {'crop_id': 'CROP_WHEAT_001', 'crop_name': 'Winter Wheat', 'crop_category': 'Grain',
             'expected_yield_per_acre': 65, 'market_price_per_unit': 6.75},
            {'crop_id': 'CROP_TOMATO_001', 'crop_name': 'Tomatoes', 'crop_category': 'Vegetable',
             'expected_yield_per_acre': 25, 'market_price_per_unit': 1200.00},
            {'crop_id': 'CROP_POTATO_001', 'crop_name': 'Potatoes', 'crop_category': 'Vegetable',
             'expected_yield_per_acre': 18, 'market_price_per_unit': 8.50}
        ]
        self.crops_df = pd.DataFrame(crops_data)

        # Generate sensor readings
        sensor_data = []
        start_date = datetime(2024, 1, 1)

        for field_id in self.fields_df['field_id'].head(50):  # Limit for demo
            for days in range(0, 365, 7):  # Weekly readings
                reading_date = start_date + timedelta(days=days)

                for sensor_type in ['soil_moisture', 'temperature', 'ph', 'nitrogen']:
                    if sensor_type == 'soil_moisture':
                        value = np.random.uniform(20, 80)
                        unit = 'percentage'
                    elif sensor_type == 'temperature':
                        base_temp = 50 + 30 * np.sin(2 * np.pi * days / 365)  # Seasonal pattern
                        value = base_temp + np.random.normal(0, 5)
                        unit = 'fahrenheit'
                    elif sensor_type == 'ph':
                        value = np.random.uniform(5.5, 7.5)
                        unit = 'ph'
                    else:  # nitrogen
                        value = np.random.uniform(10, 50)
                        unit = 'ppm'

                    sensor_data.append({
                        'reading_id': f'READING_{len(sensor_data):06d}',
                        'field_id': field_id,
                        'sensor_type': sensor_type,
                        'reading_value': value,
                        'reading_unit': unit,
                        'reading_timestamp': reading_date,
                        'data_quality_score': np.random.uniform(0.85, 1.0)
                    })

        self.sensor_readings_df = pd.DataFrame(sensor_data)

        # Generate field operations
        operations_data = []
        for field_id in self.fields_df['field_id'].head(20):
            crop_id = np.random.choice(self.crops_df['crop_id'])

            # Planting
            plant_date = start_date + timedelta(days=np.random.randint(90, 150))
            operations_data.append({
                'operation_id': f'OP_{len(operations_data):06d}',
                'field_id': field_id,
                'crop_id': crop_id,
                'operation_type': 'planting',
                'operation_date': plant_date,
                'total_cost': np.random.uniform(150, 300)
            })

            # Fertilizing
            fert_date = plant_date + timedelta(days=np.random.randint(30, 60))
            operations_data.append({
                'operation_id': f'OP_{len(operations_data):06d}',
                'field_id': field_id,
                'crop_id': crop_id,
                'operation_type': 'fertilizing',
                'operation_date': fert_date,
                'total_cost': np.random.uniform(200, 500)
            })

        self.field_operations_df = pd.DataFrame(operations_data)

        # Generate harvest records
        harvest_data = []
        for field_id in self.fields_df['field_id'].head(15):
            crop_id = np.random.choice(self.crops_df['crop_id'])
            expected_yield = self.crops_df[self.crops_df['crop_id'] == crop_id]['expected_yield_per_acre'].values[0]
            market_price = self.crops_df[self.crops_df['crop_id'] == crop_id]['market_price_per_unit'].values[0]
            field_acres = self.fields_df[self.fields_df['field_id'] == field_id]['field_acres'].values[0]

            actual_yield_per_acre = expected_yield * np.random.uniform(0.8, 1.2)
            total_yield = actual_yield_per_acre * field_acres

            harvest_data.append({
                'harvest_id': f'HARVEST_{len(harvest_data):06d}',
                'field_id': field_id,
                'crop_id': crop_id,
                'harvest_date': start_date + timedelta(days=np.random.randint(200, 300)),
                'yield_per_acre': actual_yield_per_acre,
                'yield_quantity': total_yield,
                'quality_grade': np.random.choice(['Premium', 'Good', 'Fair'], p=[0.3, 0.5, 0.2]),
                'market_price_per_unit': market_price,
                'total_revenue': total_yield * market_price
            })

        self.harvest_records_df = pd.DataFrame(harvest_data)

        st.success("‚úÖ Sample synthetic data generated successfully!")

    def create_farm_overview_dashboard(self):
        """Create comprehensive farm overview visualizations using Streamlit and Plotly"""
        st.header("üöú Farm Overview Dashboard")
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Farm Distribution by State")
            state_counts = self.farms_df['location_state'].value_counts().reset_index()
            state_counts.columns = ['location_state', 'count']
            fig = px.bar(state_counts, x='location_state', y='count',
                         title='Farm Distribution by State',
                         labels={'location_state': 'State', 'count': 'Number of Farms'},
                         color='count', color_continuous_scale=px.colors.sequential.Teal)
            st.plotly_chart(fig, use_container_width=True)

        with col2:
            st.subheader("Farm Types Distribution")
            farm_type_counts = self.farms_df['farm_type'].value_counts().reset_index()
            farm_type_counts.columns = ['farm_type', 'count']
            fig = px.pie(farm_type_counts, values='count', names='farm_type',
                         title='Distribution of Farm Types',
                         hole=0.4,
                         color_discrete_sequence=px.colors.qualitative.Pastel)
            st.plotly_chart(fig, use_container_width=True)

        col3, col4 = st.columns(2)
        with col3:
            st.subheader("Average Farm Size by State")
            avg_size = self.farms_df.groupby('location_state')['total_acres'].mean().reset_index()
            fig = px.bar(avg_size, x='location_state', y='total_acres',
                         title='Average Farm Size by State',
                         labels={'location_state': 'State', 'total_acres': 'Average Acres'},
                         color='total_acres', color_continuous_scale=px.colors.sequential.Greens)
            st.plotly_chart(fig, use_container_width=True)

        with col4:
            st.subheader("Organic Certification Status")
            organic_counts = self.farms_df['certification_organic'].value_counts().reset_index()
            organic_counts.columns = ['is_organic', 'count']
            organic_counts['label'] = organic_counts['is_organic'].apply(lambda x: 'Organic Certified' if x else 'Not Certified')
            fig = px.pie(organic_counts, values='count', names='label',
                         title='Organic Certification Status',
                         color='label',
                         color_discrete_map={'Organic Certified':'forestgreen', 'Not Certified':'sandybrown'})
            st.plotly_chart(fig, use_container_width=True)

    # def create_sensor_analytics(self):
    #     """Create sensor data analytics and trends using Streamlit and Plotly"""
    #     st.header("üîç Sensor Analytics")
    #     if len(self.sensor_readings_df) > 0:
    #         # Temperature trends over time
    #         st.subheader("Temperature Trends Throughout the Year")
    #         temp_data = self.sensor_readings_df[
    #             self.sensor_readings_df['sensor_type'] == 'temperature'
    #         ].copy()

    #         if not temp_data.empty:
    #             temp_data['month'] = temp_data['reading_timestamp'].dt.month
    #             monthly_temps = temp_data.groupby('month')['reading_value'].agg(['mean', 'std']).reset_index()

    #             fig = go.Figure()

    #             fig.add_trace(go.Scatter(
    #                 x=monthly_temps['month'],
    #                 y=monthly_temps['mean'],
    #                 mode='lines+markers',
    #                 name='Average Temperature',
    #                 line=dict(color='red', width=3),
    #                 error_y=dict(type='data', array=monthly_temps['std'], visible=True)
    #             ))

    #             fig.update_layout(
    #                 title='Average Temperature with Standard Deviation',
    #                 xaxis_title='Month',
    #                 yaxis_title='Temperature (¬∞F)',
    #                 height=500
    #             )
    #             st.plotly_chart(fig, use_container_width=True)
    #         else:
    #             st.info("No temperature data available for analysis.")

    #         # Multi-sensor heatmap
    #         st.subheader("Sensor Readings Heatmap by Month")
    #         sensor_pivot = self.sensor_readings_df.pivot_table(
    #             values='reading_value',
    #             index=self.sensor_readings_df['reading_timestamp'].dt.month,
    #             columns='sensor_type',
    #             aggfunc='mean'
    #         )

    #         fig, ax = plt.subplots(figsize=(12, 8))
    #         sns.heatmap(sensor_pivot, annot=True, fmt='.1f', cmap='RdYlBu_r', ax=ax)
    #         ax.set_title('Sensor Readings Heatmap by Month')
    #         ax.set_xlabel('Sensor Type')
    #         ax.set_ylabel('Month')
    #         st.pyplot(fig, use_container_width=True)
    #     else:
    #         st.info("No sensor readings data available.")

    def create_crop_performance_analysis(self):
        """Analyze crop performance and yield efficiency"""
        st.header("üåæ Crop Performance Analysis")
        if len(self.harvest_records_df) > 0:
            # Merge harvest data with crop information
            crop_performance = self.harvest_records_df.merge(
                self.crops_df[['crop_id', 'crop_name', 'expected_yield_per_acre']],
                on='crop_id'
            )

            # Calculate yield efficiency
            crop_performance['yield_efficiency'] = (
                    crop_performance['yield_per_acre'] / crop_performance['expected_yield_per_acre'] * 100
            )

            # Interactive dropdown for crop selection
            selected_crops = st.multiselect(
                "Select Crop(s) to view:",
                options=crop_performance['crop_name'].unique(),
                default=crop_performance['crop_name'].unique()
            )
            filtered_performance = crop_performance[crop_performance['crop_name'].isin(selected_crops)]

            if not filtered_performance.empty:
                col1, col2 = st.columns(2)

                with col1:
                    st.subheader("Yield vs Expected Yield")
                    fig = px.scatter(filtered_performance,
                                     x='expected_yield_per_acre',
                                     y='yield_per_acre',
                                     color='crop_name',
                                     hover_data=['field_id'],
                                     title='Actual Yield vs. Expected Yield per Acre',
                                     labels={'expected_yield_per_acre': 'Expected Yield (per Acre)',
                                             'yield_per_acre': 'Actual Yield (per Acre)'})
                    st.plotly_chart(fig, use_container_width=True)

                with col2:
                    st.subheader("Yield Efficiency by Crop")
                    efficiency_avg = filtered_performance.groupby('crop_name')['yield_efficiency'].mean().reset_index()
                    fig = px.bar(efficiency_avg, x='crop_name', y='yield_efficiency',
                                 title='Average Yield Efficiency by Crop (%)',
                                 labels={'crop_name': 'Crop', 'yield_efficiency': 'Efficiency (%)'})
                    st.plotly_chart(fig, use_container_width=True)

                col3, col4 = st.columns(2)

                with col3:
                    st.subheader("Revenue by Crop")
                    revenue_by_crop = filtered_performance.groupby('crop_name')['total_revenue'].sum().reset_index()
                    fig = px.bar(revenue_by_crop, x='crop_name', y='total_revenue',
                                 title='Total Revenue by Crop',
                                 labels={'crop_name': 'Crop', 'total_revenue': 'Total Revenue ($)'})
                    st.plotly_chart(fig, use_container_width=True)

                with col4:
                    st.subheader("Quality Grade Distribution")
                    quality_counts = filtered_performance['quality_grade'].value_counts().reset_index()
                    quality_counts.columns = ['quality_grade', 'count']
                    fig = px.pie(quality_counts, values='count', names='quality_grade',
                                 title='Distribution of Quality Grades',
                                 color_discrete_sequence=px.colors.qualitative.Vivid)
                    st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("No data available for the selected crops.")
        else:
            st.info("No harvest records data available.")

    def create_operational_efficiency_dashboard(self):
        """Create operational efficiency and cost analysis"""
        st.header("‚öôÔ∏è Operational Efficiency Dashboard")
        if len(self.field_operations_df) > 0:
            col1, col2 = st.columns(2)

            with col1:
                st.subheader("Operations Cost by Type")
                cost_by_op = self.field_operations_df.groupby('operation_type')['total_cost'].sum().reset_index()
                fig = px.bar(cost_by_op, x='operation_type', y='total_cost',
                             title='Total Cost by Operation Type',
                             labels={'operation_type': 'Operation Type', 'total_cost': 'Total Cost ($)'},
                             color='total_cost', color_continuous_scale=px.colors.sequential.Plasma)
                st.plotly_chart(fig, use_container_width=True)

            with col2:
                st.subheader("Monthly Operations Timeline")
                ops_monthly = self.field_operations_df.copy()
                ops_monthly['month'] = ops_monthly['operation_date'].dt.month
                monthly_cost = ops_monthly.groupby(['month', 'operation_type'])['total_cost'].sum().reset_index()

                fig = px.line(monthly_cost, x='month', y='total_cost', color='operation_type',
                              title='Monthly Operations Cost Trend',
                              labels={'month': 'Month', 'total_cost': 'Total Cost ($)'})
                st.plotly_chart(fig, use_container_width=True)

            col3, col4 = st.columns(2)
            with col3:
                st.subheader("Cost Distribution")
                fig = px.histogram(self.field_operations_df, x='total_cost',
                                   title='Distribution of Total Operation Costs',
                                   labels={'total_cost': 'Total Cost ($)'},
                                   nbins=20)
                st.plotly_chart(fig, use_container_width=True)

            with col4:
                st.subheader("Operations Count by Type")
                op_counts = self.field_operations_df['operation_type'].value_counts().reset_index()
                op_counts.columns = ['operation_type', 'count']
                fig = px.pie(op_counts, values='count', names='operation_type',
                             title='Count of Operations by Type',
                             hole=0.4,
                             color_discrete_sequence=px.colors.qualitative.Tonal)
                st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("No field operations data available.")

    def create_profitability_analysis(self):
        """Create comprehensive profitability analysis"""
        st.header("üí∞ Profitability Analysis Dashboard")
        if len(self.harvest_records_df) > 0 and len(self.field_operations_df) > 0:
            # Calculate profitability by field
            field_revenue = self.harvest_records_df.groupby('field_id')['total_revenue'].sum()
            field_costs = self.field_operations_df.groupby('field_id')['total_cost'].sum()

            profitability = pd.DataFrame({
                'field_id': field_revenue.index,
                'revenue': field_revenue.values,
                'costs': field_costs.reindex(field_revenue.index).fillna(0).values
            })
            profitability['profit'] = profitability['revenue'] - profitability['costs']
            profitability['profit_margin'] = (profitability['profit'] / profitability['revenue'] * 100).fillna(0)

            # Merge with field information
            profitability = profitability.merge(
                self.fields_df[['field_id', 'field_acres', 'soil_type']],
                on='field_id'
            )
            profitability['profit_per_acre'] = (profitability['profit'] / profitability['field_acres']).fillna(0)

            # Interactive widget to select number of top fields
            top_n = st.slider("Select number of top fields to display:", 5, 20, 10)

            col1, col2 = st.columns(2)
            with col1:
                st.subheader("Profit vs Revenue")
                fig = px.scatter(profitability, x='revenue', y='profit',
                                 hover_data=['field_id', 'profit_per_acre'],
                                 title='Profit vs. Revenue per Field',
                                 labels={'revenue': 'Total Revenue ($)', 'profit': 'Total Profit ($)'})
                st.plotly_chart(fig, use_container_width=True)

            with col2:
                st.subheader("Profit by Soil Type")
                fig = px.box(profitability, x='soil_type', y='profit_per_acre',
                             title='Profit per Acre by Soil Type',
                             labels={'soil_type': 'Soil Type', 'profit_per_acre': 'Profit per Acre ($)'})
                st.plotly_chart(fig, use_container_width=True)

            col3, col4 = st.columns(2)
            with col3:
                st.subheader("Profit Margin Distribution")
                fig = px.histogram(profitability, x='profit_margin', nbins=20,
                                   title='Distribution of Profit Margins (%)',
                                   labels={'profit_margin': 'Profit Margin (%)'})
                st.plotly_chart(fig, use_container_width=True)

            with col4:
                st.subheader(f"Top {top_n} Profitable Fields (by Profit/Acre)")
                top_fields = profitability.nlargest(top_n, 'profit_per_acre')
                fig = px.bar(top_fields, x='field_id', y='profit_per_acre',
                             title=f'Top {top_n} Profitable Fields',
                             labels={'field_id': 'Field ID', 'profit_per_acre': 'Profit per Acre ($)'},
                             color='profit_per_acre', color_continuous_scale=px.colors.sequential.Viridis)
                st.plotly_chart(fig, use_container_width=True)

            st.markdown("---")
            st.subheader("üìä PROFITABILITY SUMMARY")
            total_revenue = profitability['revenue'].sum()
            total_costs = profitability['costs'].sum()
            total_profit = profitability['profit'].sum()
            avg_profit_margin = profitability['profit_margin'].mean()
            best_field = profitability.loc[profitability['profit_per_acre'].idxmax()]

            st.write(f"**Total Revenue:** ${total_revenue:,.2f}")
            st.write(f"**Total Costs:** ${total_costs:,.2f}")
            st.write(f"**Total Profit:** ${total_profit:,.2f}")
            st.write(f"**Average Profit Margin:** {avg_profit_margin:.1f}%")
            st.write(f"**Best Performing Field:** {best_field['field_id']} with a profit of ${best_field['profit_per_acre']:.2f} per acre.")
        else:
            st.info("Insufficient data for profitability analysis (missing harvest or operations data).")

    def generate_executive_summary(self):
        """Generate executive summary with key metrics"""
        st.header("üéØ Executive Summary")
        st.markdown("---")

        st.subheader("üìç Farm Portfolio Overview")
        st.write(f"**Total Farms:** {len(self.farms_df):,}")
        st.write(f"**Total Fields:** {len(self.fields_df):,}")
        st.write(f"**Total Acreage:** {self.farms_df['total_acres'].sum():,.1f} acres")
        st.write(f"**Average Farm Size:** {self.farms_df['total_acres'].mean():.1f} acres")

        if len(self.sensor_readings_df) > 0:
            st.subheader("üì° Sensor Data Insights")
            st.write(f"**Total Sensor Readings:** {len(self.sensor_readings_df):,}")
            st.write(f"**Average Data Quality Score:** {self.sensor_readings_df['data_quality_score'].mean():.1%}")
            monitoring_period = (self.sensor_readings_df['reading_timestamp'].max() - self.sensor_readings_df['reading_timestamp'].min()).days
            st.write(f"**Active Monitoring Period:** {monitoring_period} days")

        if len(self.harvest_records_df) > 0:
            total_yield = self.harvest_records_df['yield_quantity'].sum()
            total_revenue = self.harvest_records_df['total_revenue'].sum()
            st.subheader("üåæ Harvest Performance")
            st.write(f"**Total Yield:** {total_yield:,.1f} units")
            st.write(f"**Total Revenue:** ${total_revenue:,.2f}")
            avg_rev_per_acre = total_revenue / self.fields_df['field_acres'].sum()
            st.write(f"**Average Revenue per Acre:** ${avg_rev_per_acre:.2f}")

        if len(self.field_operations_df) > 0:
            total_op_cost = self.field_operations_df['total_cost'].sum()
            most_common_op = self.field_operations_df['operation_type'].mode().iloc[0]
            st.subheader("‚öôÔ∏è Operational Metrics")
            st.write(f"**Total Operations:** {len(self.field_operations_df):,}")
            st.write(f"**Total Operational Costs:** ${total_op_cost:,.2f}")
            st.write(f"**Most Common Operation:** {most_common_op}")

        st.subheader("üéØ KINGFISHER SYNTHETIC DATA GENERATOR BENEFITS:")
        st.markdown("""
        * ‚úÖ Generated comprehensive agricultural dataset
        * ‚úÖ Enabled advanced analytics without real data exposure
        * ‚úÖ Supported ML model training and validation
        * ‚úÖ Facilitated dashboard development and testing
        * ‚úÖ Provided scalable data for performance testing
        """)
        st.markdown("---")

def main():
    """Main Streamlit application function"""
    st.set_page_config(layout="wide", page_title="Precision Agriculture Dashboard", page_icon="üå±")
    st.title("üå± Precision Agriculture Analytics Dashboard")
    st.subheader("Powered by Kingfisher Synthetic Data Generator")

    # Initialize dashboard and load data
    dashboard = AgricultureAnalyticsDashboard()
    with st.spinner('Loading or generating data...'):
        dashboard.load_data()

    # Create sections for the dashboard
    st.sidebar.title("Dashboard Navigation")
    section = st.sidebar.radio("Go to", [
        "Farm Overview",
        # "Sensor Analytics",
        "Crop Performance",
        "Operational Efficiency",
        "Profitability Analysis",
        "Executive Summary"
    ])

    if section == "Farm Overview":
        dashboard.create_farm_overview_dashboard()
    # elif section == "Sensor Analytics":
    #     dashboard.create_sensor_analytics()
    elif section == "Crop Performance":
        dashboard.create_crop_performance_analysis()
    elif section == "Operational Efficiency":
        dashboard.create_operational_efficiency_dashboard()
    elif section == "Profitability Analysis":
        dashboard.create_profitability_analysis()
    elif section == "Executive Summary":
        dashboard.generate_executive_summary()

if __name__ == "__main__":
    main()